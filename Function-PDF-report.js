/**
 * PDFController - Test of modules to generate PDF files using EJS HTML templates and Puppeteer
 */

/**
 * PDF libraries required.
 */
const Puppeteer = require('puppeteer'); // PDF generator (Chromium headless)
const ejs = require('ejs'); // JavaScript embebbed on HTML templates

// If you need use the files directly and not from the DB
const fs = require('fs');
const path = require('path');
//const ejsPath = path.join(__dirname, '/files/Template-V1/TemplateHTML.ejs');

/**
 * An example of microservice to request a PDF to the function presented.
 */
module.exports = {
    reportPDF: async function (req, res) {

        // Columns as JSON, can be used to filter attributes just by the columns needed
        // Can be null if you need
        const columns = {
            name: "Nombre", 
            rut: "RUT", 
            address: "Dirección",
            town: "Ciudad",
            test: "Test 123 probando"
        };

        // A data example to test
        const data = [
            {
                "name": "Pepito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Coñaripe",
                "description": "Probando 123 test prueba 123 prueba 123 prueba 123"
            },
            {
                "name": "Juanito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Lican Ray",
                "description": "Probando 123 test"
            },
            {
                "name": "Pepito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Villarrica",
                "description": "Probando 123 test prueba 123 prueba 123 prueba"
            },
            {
                "name": "Rocky",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Pucón",
                "description": "Una descripción"
            },
            {
                "name": "Pedrito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Hornopirén",
                "description": "Probando 123 test prueba 123 prueba 123 prueba 123"
            },
            {
                "name": "Juanito",
                "rut": "18.808.707-3",
                "address": "Avenida Siempre Grande",
                "town": "Puerto Fuy",
                "description": "Probando 123 test prueba 123"
            }
        ]

        // Business, user and report info for the PDF
        const business = {
            name: 'Novosystem SpA',
            address: 'Av Pajaritos N°3195, Of 1411',
            town: 'Maipu',
            city: 'Santiago'
        };
        const user = {
            name: 'Charles Aránguiz',
            module: 'Desarrollo web'
        };
        const report = {
            title: 'Un título',
            subtitle: 'Un subtítulo'
        };

        const colWidth = 13; // This value is used to measure the width of the columns, further details in the function

        generatePDFv1(data, columns, business, user, report, colWidth).then((pdf) => {
            res.set({
                'Content-Type': 'application/pdf',
                'Content-Length': pdf.length
            });
            res.status(200).send(pdf);
        });
        // Observation: the response data of the PDF it's a buffer type.
        // Most browsers will recognize the 'application/pdf' and open it for default with PDF.js (e.g. Chrome/Firefox/Edge-Chromium)
        // Few others will not, then we have to convert the buffer data into a .PDF file in the front-end if needed, but doesn't seem to be needed if we don't use IE or something.
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This function generates a PDF file by printing an HTML document.
 * The HTML is generated by a EJS template (HTML with JS embebbed)
 * @Version {1.3}: This version allows to generate responsive reports with a header-body-footer per page.
 * To make it we define a fixed size of columns, with a @colWidth (except 1st and last columns, which are fixed and automatic, respectively).
 * Then, it's important to test your proper value for @colWidth depending of your needs: how many columns, or if you need change the layout, etc.
 * As a key part, this function uses a @calculateRows function, that will calculate the number of rows for each page given the @colWidth @data and @columns
 * @param {*} data : the data for the report
 * @param {*} columns : the columns names that will be headers of the data, can be used
 * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
 * @param {*} business : the business info for the report
 * @param {*} user : user that generates the report
 * @param {*} report : report's info: title and subtitle
 * @param {*} colWidth : width for each columns (except 1st and last columns, which are fixed and automatic, respectively).
 * @return : PDF file (as a buffer).
 */
async function generatePDFv1(data, columns, business, user, report, colWidth) {
    let d = new Date();
    const day = d.getDate();
    const month = d.getMonth() + 1; //Month starts from 0
    const year = d.getFullYear();
    const date = `${day}-${month}-${year}`;

    // Charging the EJS template from a file, then render to HTML
    //let templateEjs = fs.readFileSync(ejsPathV1, 'utf8'); // If you need use the file directly and not from DB

    // Read from database (table template_html)
    let base = await TemplateHTML.findOne({ id: 1 });
    let header = await TemplateHTML.findOne({ id: 3 });
    let body = await TemplateHTML.findOne({ id: 4 });
    let footer = await TemplateHTML.findOne({ id: 5 });

    // Initialize the html's base and add each module (header, body, footer)
    let templateEjs = base.html;
    templateEjs = templateEjs.replace('{header}', header.html);
    templateEjs = templateEjs.replace('{body}', body.html);
    templateEjs = templateEjs.replace('{footer}', footer.html);

    // Load the css, to be asigned with the puppeteer call
    let css = await TemplateHTML.findOne({ id: 2 });
    css = css.html; // That html doesn't mind something, it's just CSS

    if (!colWidth) {
        colWidth = 8;
    }

    let keyHeaders;

    // Variable to get the name of headers columns, to generate the html body
    let dataColumns = [];
    
    // If there's no columns defined, we use the default names
    if(!columns) {
        keyHeaders = Object.keys(data[0]);
        columns = [];
        keyHeaders.forEach(header => {
            columns.push(header);
        });
        dataColumns = columns.slice();
    }
    else { // If columns are defined
        keyHeaders = Object.keys(columns);
        keyHeaders.forEach(header => {
            dataColumns.push(header);
        });

        let headers = Object.values(columns);
        columns = [];

        headers.forEach(header => {
            columns.push(header);
        });
    }

    // This function will calculate how many rows will be printed for each page, according to the given values.
    const arrayRowsPerPage = calculateRows(data, dataColumns, colWidth);

    // Get the number of pages
    const pages = arrayRowsPerPage.length;
    let finalData = []; // The array that will contain arrays with the data for each page
    if (pages > 1) {
        let rowsPreviousPage = 0;
        for(i=0; i < pages; i++) {
            const rowsCurrentPage = arrayRowsPerPage[i];
            finalData.push(data.slice(rowsPreviousPage, rowsCurrentPage + rowsPreviousPage));
            rowsPreviousPage += rowsCurrentPage;
        }
    } else {
        finalData.push(data);
    }

    let html;
    // Creates the HTML passing the request data (as example)
    html = ejs.render(templateEjs, {
        columns: columns,
        dataColumns: dataColumns,
        arrayData: finalData,
        business: business,
        user: user,
        date: date,
        report: report,
        pages: pages,
        arrayRowsPerPage: arrayRowsPerPage
    });
    
    /**
     * Pendiente de ver si el puppeteer puede ser lanzado al iniciar la app.
     * Además, ver si es que se puede también dejar iniciada una page.
     * Revisar opciones (por tema de rendimiento).
     */
    // Start the puppeteer API, headless
    const browser = await Puppeteer.launch({ 
        headless: true, 
        args: ['--no-sandbox'] 
    });
    const page = await browser.newPage();

    // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
    await page.setContent(html);

    // Set the css styles
    await page.addStyleTag({content: css})
    //await page.addStyleTag({path: 'files/Template-V1.3/style.css'});

    // Define the width of columns (except 1st -an id- and last -auto width-)
    await page.addStyleTag({content: `.table-cols {width: ${colWidth}%;}`});
    
    const pdf = await page.pdf({
        format: 'A4',
        printBackground: true
    });

    // Close the puppeteer API and return the PDF buffer
    await browser.close();
    return pdf;
}

/**
 * This functions calculates the numbers of rows for each page of the report, according to the length of the strings
 * of the data and the width of the columns.
 * Important: this function only will work if you check the @colWidth proper for you amount of columns.
 * For example, for the layout defined and for 10 columns, a @colWidth of 9 could work
 * (maybe 10, depends of your 1st and last column, we define a fixed 1st column of index and automatic size of last column, but can be fixed)
 * @param {*} data : the data for the report to be analyzed
 * @param {*} columns : the columns that will be reported, needed to filter the analysis only to necessary attributes
 * @param {*} colWidth : the width predefined of the columns (the report only will work for fixed values, we suggest test it a bit)
 * @return : array with rows for each page.
 */
function calculateRows(data, dataColumns, colWidth) {
    const referenceLines = 42; // Value of reference to measure how many lines fills a page's body (depends of layout)
    let arrayRowsPerPage = []; // The array that will contain (different) values of rows to generate for each page
    let sumLines = 0; // Sum of lines for a current page, with this value can be controlled the rows per page
    let currentLines; // Current lines in a iteration (max value for a given page)
    let countRows = 0; // Counter for a given page
    let newLines; // New lines for a new iteration (if it's bigger than previous currentLines, then we equal currentLines to newLines)

    //const columnsKeys = Object.keys(dataColumns);
    const dataLength = data.length;

    data.map((value, index) => {
        currentLines = 0; // Starts from 0 for each json value
        for(key in value) {
            if (dataColumns.includes(key)) {
                if (!typeof value[key] === 'string' && !value[key] instanceof String){ // Parsing to strings to check lengths
                    value[key] = value[key].toString();
                }
                const lengthAttribute = value[key].length;
                newLines = Math.ceil(lengthAttribute/colWidth); // Round the value up

                if (newLines > currentLines) { // If it's bigger than previous currentLines, then we equal currentLines to newLines
                    currentLines = newLines;
                }
            }
        }
        if (sumLines + currentLines <= referenceLines) { // If the next sumLines it's not bigger than referenceLines, add the current to sum (adds to current page)
            sumLines += currentLines;
            countRows++; // With that amount of lines for a value = 1 new row
        }
        else { // If the next sumLines could overflow referenceLines, we define a page with the current countRows and start a new one
            arrayRowsPerPage.push(countRows); // Add a new page
            sumLines = currentLines; // Start new page with the currentLines
            countRows = 1; // Starts with one row (because sumLines contains one currentLines)
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (index + 1 == dataLength) { // The final value, then we need to add current rows for last page
            arrayRowsPerPage.push(countRows); // Add the final page
        }
    });

    return arrayRowsPerPage; // Return the array with each value of rows for each page
}