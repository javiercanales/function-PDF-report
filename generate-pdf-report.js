/**
 * This file includes a util function to generate responsive PDF reports
 * with totals and subtotals for given columns (both if required).
 * 
 * To reach the total-subtotal functionality the function will use a GroupBy function, grouping given a set of criterias (keys).
 * The function allows to use more than one column with subtotal/total and multiple criteria keys.
 * Also allows to generate basic reports or with totals only.
 * @Version : 4 (expected to be the final)
 */

/* PDF libraries required */
const Puppeteer = require('puppeteer'); // PDF generator (Chromium headless)
const ejs = require('ejs'); // JavaScript embebbed on HTML templates
const _ = require('lodash'); // Library to work with arrays and other utils (e.g. GroupBy, etc)

// If you need use the files directly and not from the DB
//const fs = require('fs');
//const path = require('path');
//const ejsPath = path.join(__dirname, '../../files/Template-V4/TemplateHTML.ejs');

const templateType = {
    BASE: '1', // Base template with {header},{body} and {footer}
    CSS: '2',
    HEADER: '3',
    BODY: '4',
    FOOTER: '5'
};

module.exports = {
    /**
     * This function generate a PDF file by printing an HTML document.
     * The HTML is generated by a EJS template (HTML with JS embebbed)
     * @Version {4}: This versión it's based on a whole table, and
     * allows to generate responsive reports from columns to rows, with
     * the header-body-footer format per page, and gives a total value and subtotal value for
     * given columns if it's instructed (via a total boolean and subtotal key -to group subtotals- attributes of columns).
     * Also allows transform a column number to a price format
     * 
     * @param {*} data : the data for the report
     * @param {*} columns : the columns names that will be headers of the data, can be used
     * to filter columns from the data (by adding to @columns only what you want), or can be null (takes all columns)
     * @param {*} subtotalKeys : keys to group and generate subtotals
     * @param {*} business : the business info for the report
     * @param {*} user : user that generates the report
     * @param {*} report : report's info: title and subtitle
     * @param {*} index : when need index, you can set it by defining true/false a includeIndex and a width
     */
    generatePdfReport: async function (data, columns, subtotalCriteriaKeys, business, user, report, index) {
        let d = new Date();
        let day = d.getDate();
        let month = d.getMonth() + 1; // Month starts from 0
        let year = d.getFullYear();
        
        let hours = d.getHours();
        let minutes =  d.getMinutes();

        // Format the numbers of date attributes if < 10
        if (day < 10) {
            day = `0${day}`
        }
        if (month < 10) {
            month = `0${month}`
        }
        if (hours < 10) {
            hours = `0${hours}`
        }
        if (minutes < 10) {
            minutes = `0${minutes}`
        }

        const date = `${day}-${month}-${year} ${hours}:${minutes}`;

        /**
         * FormatMoney.
         * A internal function to format a number to a money string
         * @param {*} decPlaces : number of decimals (decPlaces = 2 => 0.00)
         * @param {*} thouSeparator : separator for thousands (e.g. ',' or '.')
         * @param {*} decSeparator : separator for decimals (e.g. ',' or '.')
         */
        formatMoney = function(number, decPlaces, thouSeparator, decSeparator) {
            var n = number,
                decPlaces = isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces,
                decSeparator = decSeparator == undefined ? "." : decSeparator,
                thouSeparator = thouSeparator == undefined ? "," : thouSeparator,
                sign = n < 0 ? "-" : "",
                i = parseInt(n = Math.abs(+n || 0).toFixed(decPlaces)) + "",
                j = (j = i.length) > 3 ? j % 3 : 0;
            return sign + (j ? i.substr(0, j) + thouSeparator : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thouSeparator) + (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : "");
        };

        /**
         * Group collection's data by multiple iteratees
         * @param data
         * @param {Array<String|GroupByProp>} keys Array of group by objects or property names
         *   This parameter also can contain both property names and group by objects together
         * @returns {Array}
         */
        function groupBy(data, keys) {

            let genrows = function(groups, groupKey) {
                return _.toPairs(groups).map(([key, data]) => ({ [groupKey]: key, data }));
            }
            let gengroups = function(arr, iteratee, key) {
                const grouped = _.groupBy(arr, iteratee);
                return genrows(grouped, key);
            }

            let result = [{ data }];

            keys.forEach((prop, i) => {
                const key = prop.key || `k${i + 1}`;
                const iteratee = prop.iteratee || prop;

                result = _.flatten(
                    result.map((row) => {
                        return gengroups(row.data, iteratee, key).map((group) =>
                            Object.assign({}, row, {
                                [key]: group[key],
                                data: group.data
                            })
                        );
                    })
                );
            });

            return _.flatten(result);
        }

        /* Normal supporters */
        let dataKeys = []; // Variable to get the column keys (identifiers to match data), to generate the html body
        let headerNames = []; // Variable to get the header names (names for the report)
        let colWidths = []; // Widths for the columns (only if columns is defined)
        let formatters = []; // Control formats for each columns
        
        /* Subtotals supporters */
        let hasSubtotal = false;
        let subtotalDataKeys = []; // Variable to get the column keys (identifiers to match data), to generate the html body
        let subtotalHeaderNames = []; // Variable to get the header names (names for the report)
        let subtotalColWidths = []; // Widths for the columns (only if columns is defined)
        let subtotalFormatters = []; // Control formats for each columns
        let subtotalList = [];
        let subtotalKeys = [];
        let dataGrouped; // Variable to apply GroupBy function by a given criteria (key)
        let currentKeys = []; // A "pointer" to control subtotals
        let headerCriteriaNames = [];
        let criteriaFormatters = [];
        let totalFormatters = [];
        let subtotalOffset = [];

        /* Totals */
        let hasTotal;
        let hasTotalButNotSubtotal = false;
        let totals = []; // Variable to add totals
        let totalsForSubtotals = []; // Variable to add totals
        let totalKeys = [];

        // If there's no columns defined, we use the default names
        if (!columns) {
            
            headerNames = Object.keys(data[0]); // Get the keys from data
            dataKeys = headerNames.slice(); // The keys to match data
        }
        else { // If columns are defined
            columns.map((value, i) => {
                if (value.subtotal) {
                    hasSubtotal = true;
                    subtotalKeys.push(value.key);
                    if (value.format) {
                        criteriaFormatters.push(value.format);
                    } else {
                        criteriaFormatters.push(false);
                    }
                }
                if (value.total) {
                    hasTotal = true;
                    if (value.format) {
                        totalFormatters.push(value.format);
                    } else {
                        totalFormatters.push(false);
                    }
                    totalKeys.push(value.key);
                }

                // Variables for the reports without subtotals
                // If the key has a header add it as header name, otherwise use the key as name (and key of course)
                if (value.header) {
                    dataKeys.push(value.key);
                    headerNames.push(value.header);
                } else {
                    dataKeys.push(value.key);
                    headerNames.push(value.key);
                }
                // To define widths for the columns. If there's no width, set 'auto' to the column
                if (value.width) {
                    colWidths.push(value.width);
                } else {
                    colWidths.push('auto');
                }
                // To define if a column has format or not
                if (value.format) {
                    formatters.push(value.format);
                } else {
                    formatters.push(false); // No format for the column
                }

                // Now for the subtotal-type report
                // If the key isn´t in the criteria-keys
                // (the criteria-key properties are treated in the next lines, line 195 aprox)
                if (!(subtotalCriteriaKeys.includes(value.key))) {

                    // If the key has a header add it as header name, otherwise use the key as name (and key of course)
                    if (value.header) {
                        subtotalDataKeys.push(value.key);
                        subtotalHeaderNames.push(value.header);
                    } else {
                        subtotalDataKeys.push(value.key);
                        subtotalHeaderNames.push(value.key);
                    }
                    // To define widths for the columns. If there's no width, set 'auto' to the column
                    if (value.width) {
                        subtotalColWidths.push(value.width);
                    } else {
                        subtotalColWidths.push('auto');
                    }
                    // To define if a column has format or not
                    if (value.format) {
                        subtotalFormatters.push(value.format);
                    } else {
                        subtotalFormatters.push(false); // No format for the column
                    }
                }
                

                if (i == columns.length - 1 && hasTotal && !hasSubtotal) {
                    hasTotalButNotSubtotal = true;
                }
            });
            if (hasTotalButNotSubtotal) {
                columns.map((value, i) => {
                    if (value.total) {
                        let totalSum = 0;
                        data.map(row => { // Iterate data to sum values and format the money number
                            totalSum += row[value.key];
                        });
                        totals.push({
                            hasTotal: true,
                            totalValue: totalSum,
                            totalFormat: value.format
                        });
                    } else {
                        totals.push({
                            hasTotal: false
                        });
                    }
                });
            } else {
                for (let i=0; i<columns.length; i++) {
                    if (columns[i].subtotal) {
    
                        // The Group By function, with multiple keys
                        dataGrouped = groupBy(data, subtotalCriteriaKeys);
    
                        for (let j=0; j < subtotalKeys.length; j++) {
                            let subtotals = [];
                            for (let k=0; k < subtotalCriteriaKeys.length; k++) {
                                subtotals.push(0);
                            }
                            subtotalList.push(subtotals);
                            totalsForSubtotals.push(0);
                        }
                        
                        for(let j=1; j<=subtotalCriteriaKeys.length; j++) {
                            currentKeys.push(dataGrouped[0][`k${j}`]);
                            headerCriteriaNames.push('');
                            criteriaFormatters.push(false);
                        }
    
                        // Here the subtotal criteria's names, formats, etc, are treated
                        ////////////////////////////////////////////////////////////////
                        subtotalCriteriaKeys.map((key, j) => {
                            columns.map((value, k) => {
                                if (value.key == key) {
                                    if (value.header) {
                                        headerCriteriaNames[j] = value.header;
                                    } else {
                                        headerCriteriaNames[j] = value.key;
                                    }
                                }
                            });
                        });

                        let subtotalCounter4Cols = 0;
                        let isFirstSubtotalAdded = false;
                        for (let j=0; j < subtotalDataKeys.length; j++) {
                            if (!(subtotalKeys.includes(subtotalDataKeys[j]))) {
                                subtotalCounter4Cols++;
                            } else {
                                subtotalOffset.push(subtotalCounter4Cols);
                                if (!isFirstSubtotalAdded) {
                                    subtotalOffset.push(1);
                                    isFirstSubtotalAdded = true;
                                }
                                subtotalCounter4Cols = 1;
                            }
                        }
                        break;
                    }
                }
            }
            // If there's no subtotal criteria, the data will remain as it was

        }

        let includeIndex;
        if (!index) { // If there's no index defined
            includeIndex = false;
        } else { // If index attribute is defined
            includeIndex = index.includeIndex;
        }

        // This will be used if you have the template in the database
        // Read from database (table template_html)
        let base = await ReportTemplate.findOne({ id: templateType.BASE });
        let header = await ReportTemplate.findOne({ id: templateType.HEADER });
        let body = await ReportTemplate.findOne({ id: templateType.BODY });
        let footer = await ReportTemplate.findOne({ id: templateType.FOOTER });

        // Load the css, to be assigned with the puppeteer call
        let css = await ReportTemplate.findOne({ id: templateType.CSS });
        css = css.html; // That html doesn't mind something, it's just CSS

        // Initialize the html's base and add each module (header, body, footer)
        let templateEjs = base.html;
        templateEjs = templateEjs.replace('{{{header}}}', header.html);
        templateEjs = templateEjs.replace('{{{body}}}', body.html);
        templateEjs = templateEjs.replace('{{{footer}}}', footer.html);
        
        // Charging the EJS template from file, then render to HTML
        //let templateEjs = fs.readFileSync(ejsPath, 'utf8');
    
        let html;
        // Creates the HTML passing the request data (as example)
        html = ejs.render(templateEjs, {
            headerCriteriaNames: headerCriteriaNames,
            headerNames: headerNames,
            subtotalHeaderNames: subtotalHeaderNames,
            data: data,
            dataKeys: dataKeys,
            subtotalDataKeys: subtotalDataKeys,
            formatters: formatters,
            subtotalFormatters: subtotalFormatters,
            totalFormatters: totalFormatters,
            criteriaFormatters: criteriaFormatters,
            formatMoney: formatMoney,
            business: business,
            user: user,
            date: date,
            report: report,
            includeIndex: includeIndex,
            hasSubtotal: hasSubtotal,
            hasTotalButNotSubtotal: hasTotalButNotSubtotal,
            currentKeys: currentKeys,
            subtotalList: subtotalList,
            subtotalKeys: subtotalKeys,
            subtotalCriteriaKeys: subtotalCriteriaKeys,
            subtotalOffset: subtotalOffset,
            totals: totals,
            totalsForSubtotals: totalsForSubtotals,
            totalKeys: totalKeys,
            dataGrouped: dataGrouped,
        });
        console.log('1: EJS rendered to HTML successfully');
        
        // Start the puppeteer API, headless
        const browser = await Puppeteer.launch({ 
            headless: true, 
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
                //'--shm-size=1gb',
            ]
        });
        console.log('2: Puppeteer launched!');

        const page = await browser.newPage();
        console.log('3: New page');

        // Set the HTML to the puppeteer page, then the PDF (buffer) it's generated with some options
        await page.setContent(html).catch(err => {
            console.log(err.message);
        });
        console.log('4: HTML loaded to Puppeteer!');

        // If you have the CSS in a database
        await page.addStyleTag({content: css})
        // If you have the CSS in a file
        //await page.addStyleTag({path: 'files/Template-V4/style.css'});
        console.log('5: Loading CSS');

        if (columns) {
            if (hasSubtotal) {
                subtotalColWidths.forEach(async (colWidth, i) => {
                    await page.addStyleTag({content: `#column${i+1} {
                        width: ${colWidth}%;
                    }`});
                });
            } else {
                colWidths.forEach(async (colWidth, i) => {
                    await page.addStyleTag({content: `#column${i+1} {
                        width: ${colWidth}%;
                    }`});
                });
            }
        }
        // Define a width for index column just when columns
        // and includeIndex are defined (if columns isn't defined,
        // then let the auto-layout to define widths for all columns)
        if (columns && index) {
            if (index.width) {
                await page.addStyleTag({content: `#column0 {
                    width: ${index.width}%;
                }`});
            }
        }

        console.log('6: Starting PDF generation');
        // Create the PDF.
        // This also will generate the Pagination at the bottom (after the footer, its the only way to generate pagination with this responsive approach as far I know)
        const pdf = await page.pdf({
            format: 'A4',
            printBackground: true,
            displayHeaderFooter: true,
            footerTemplate: '<div style="font-size:8.5px; margin: auto;">Página <span class="pageNumber"></span> de <span class="totalPages"></span></div>',
            margin: {
                bottom: '75px'
            }
        });
        console.log('7: PDF generated successfully!');

        // Close the puppeteer API and return the PDF buffer
        await page.close();
        await browser.close();
        console.log('8: Puppeteer instance closed');

        return pdf;
    }
};